const fetch = require('node-fetch');

exports.handler = async (event, context) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers, body: '' };
  }

  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, headers, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const update = JSON.parse(event.body);
    
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    if (Date.now() - update.message?.date * 1000 > 60000) {
      return { statusCode: 200, headers, body: 'OK' };
    }

    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    const serverUrl = process.env.SERVER_URL || 'https://ultra-marathon-tracker.netlify.app';
    const adminIds = process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',').map(id => parseInt(id.trim())) : [];

    if (!botToken) {
      console.error('TELEGRAM_BOT_TOKEN not found in environment variables');
      return { statusCode: 500, headers, body: 'Bot token not configured' };
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
    const sendMessage = async (chatId, text, options = {}) => {
      const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
      const payload = {
        chat_id: chatId,
        text,
        parse_mode: 'HTML',
        ...options
      };
      
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        return await response.json();
      } catch (error) {
        console.error('Error sending message:', error);
        return null;
      }
    };

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ callback query
    const answerCallbackQuery = async (callbackQueryId, text = '') => {
      const url = `https://api.telegram.org/bot${botToken}/answerCallbackQuery`;
      const payload = {
        callback_query_id: callbackQueryId,
        text
      };
      
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        return await response.json();
      } catch (error) {
        console.error('Error answering callback query:', error);
        return null;
      }
    };

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∞–¥–º–∏–Ω–∞
    const isAdmin = (userId) => adminIds.includes(userId);

    // –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
    const userKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'admin_stats' }]
        ]
      }
    };

    const adminKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–º', callback_data: 'admin_add_km' },
            { text: 'üîÑ –°–±—Ä–æ—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ', callback_data: 'admin_reset' }
          ],
          [
            { text: 'üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'admin_stats' }
          ]
        ]
      }
    };

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    if (update.message) {
      const chatId = update.message.chat.id;
      const userId = update.message.from.id;
      const text = update.message.text;

      console.log(`üì± Message from ${userId}: ${text}`);

      if (text === '/start') {
        const keyboard = isAdmin(userId) ? adminKeyboard : userKeyboard;
        await sendMessage(chatId, 'üèÉ‚Äç‚ôÇÔ∏è –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç—Ä–µ–∫–µ—Ä —É–ª—å—Ç—Ä–∞–º–∞—Ä–∞—Ñ–æ–Ω–∞!\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:', keyboard);
      } else if (text === '/admin') {
        if (isAdmin(userId)) {
          await sendMessage(chatId, 'üîß –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:', adminKeyboard);
        } else {
          await sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        }
      } else if (isAdmin(userId) && !isNaN(parseFloat(text))) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∏—Å–ª–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–º/–∫—Ä—É–≥–æ–≤
        const number = parseFloat(text);
        if (number > 0) {
          try {
            const response = await fetch(`${serverUrl}/.netlify/functions/data`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ kmNumber: number })
            });
            
            if (response.ok) {
              const result = await response.json();
              await sendMessage(chatId, result.message, adminKeyboard);
            } else {
              await sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö');
            }
          } catch (error) {
            console.error('Error updating data:', error);
            await sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö');
          }
        }
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ callback queries
    if (update.callback_query) {
      const chatId = update.callback_query.message.chat.id;
      const userId = update.callback_query.from.id;
      const data = update.callback_query.data;

      console.log(`üîò Callback from ${userId}: ${data}`);

      switch (data) {
        case 'admin_add_km':
          if (isAdmin(userId)) {
            await sendMessage(chatId, '–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∏–ª–æ–º–µ—Ç—Ä–æ–≤ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', { reply_markup: { remove_keyboard: true } });
          } else {
            await sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
          }
          await answerCallbackQuery(update.callback_query.id);
          break;


        case 'admin_reset':
          if (isAdmin(userId)) {
            try {
              const response = await fetch(`${serverUrl}/.netlify/functions/data`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reset: true })
              });
              
              if (response.ok) {
                const result = await response.json();
                await sendMessage(chatId, '‚úÖ –î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω—ã –∫ –Ω—É–ª—é!\n\nüìä –ö–∏–ª–æ–º–µ—Ç—Ä—ã: 0\nüîÑ –ö—Ä—É–≥–∏: 0', adminKeyboard);
              } else {
                await sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ –¥–∞–Ω–Ω—ã—Ö');
              }
            } catch (error) {
              console.error('Error resetting data:', error);
              await sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ –¥–∞–Ω–Ω—ã—Ö');
            }
          } else {
            await sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
          }
          await answerCallbackQuery(update.callback_query.id);
          break;

        case 'admin_stats':
          try {
            // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –≤—Ä–µ–º—è –∑–∞–±–µ–≥–∞
            const [statsResp, raceTimeResp] = await Promise.all([
              fetch(`${serverUrl}/.netlify/functions/data`),
              fetch(`${serverUrl}/.netlify/functions/set_race_time`)
            ]);
            
            const stats = await statsResp.json();
            const raceTime = await raceTimeResp.json();
              
            const totalKm = Number(stats.total_km || 0);
            const totalLaps = Math.round(totalKm / 0.4);
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑—Ä—è–¥
            let rank = '-';
            let rankEmoji = '‚ö™Ô∏è';
            let nextRank = 160;
            let kmToNext = 160 - totalKm;
            
            if (totalKm >= 220) {
              rank = '–ö–ú–°';
              rankEmoji = 'üü£';
              nextRank = null;
              kmToNext = 0;
            } else if (totalKm >= 200) {
              rank = '1-–π';
              rankEmoji = 'üî¥';
              nextRank = 220;
              kmToNext = 220 - totalKm;
            } else if (totalKm >= 180) {
              rank = '2-–π';
              rankEmoji = 'üü°';
              nextRank = 200;
              kmToNext = 200 - totalKm;
            } else if (totalKm >= 160) {
              rank = '3-–π';
              rankEmoji = 'üü¢';
              nextRank = 180;
              kmToNext = 180 - totalKm;
            }
            
            // –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –∑–∞–±–µ–≥–∞ —Å —Å–µ—Ä–≤–µ—Ä–∞
            let raceStart, raceEnd;
            try {
              const raceTimeResp = await fetch(`${serverUrl}/.netlify/functions/set_race_time`);
              if (raceTimeResp.ok) {
                const raceTime = await raceTimeResp.json();
                raceStart = new Date(raceTime.race_start);
                raceEnd = new Date(raceTime.race_end);
              } else {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                raceStart = new Date('2025-10-01T14:00:00+03:00');
                raceEnd = new Date('2025-10-02T14:00:00+03:00');
              }
            } catch (error) {
              console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–±–µ–≥–∞:', error);
              raceStart = new Date('2025-10-01T14:00:00+03:00');
              raceEnd = new Date('2025-10-02T14:00:00+03:00');
            }

            const now = new Date();
            const elapsedMs = Math.max(0, now - raceStart);
            const elapsedHours = Math.floor(elapsedMs / 3600000);
            const elapsedMinutes = Math.floor((elapsedMs % 3600000) / 60000);
            const elapsedTime = elapsedHours > 0 
              ? `${elapsedHours} —á ${elapsedMinutes} –º–∏–Ω`
              : elapsedHours === 0 && now >= raceStart
                ? `${elapsedMinutes} –º–∏–Ω`
                : '–ù–µ –Ω–∞—á–∞–ª—Å—è';

            // –í—ã—á–∏—Å–ª—è–µ–º –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è
            const remainingMs = Math.max(0, raceEnd - now);
            const remainingHours = Math.floor(remainingMs / 3600000);
            const remainingMinutes = Math.floor((remainingMs % 3600000) / 60000);
            const remainingTime = now >= raceEnd
              ? '–ó–∞–≤–µ—Ä—à–µ–Ω'
              : now < raceStart
                ? '–ù–µ –Ω–∞—á–∞–ª—Å—è'
                : `${remainingHours} —á ${remainingMinutes} –º–∏–Ω`;
              
            // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            const updateDate = new Date(stats.updated_at);
            const dateStr = updateDate.toLocaleString('ru-RU', {
              timeZone: 'Europe/Volgograd',
              day: '2-digit',
              month: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            });
            
            // –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
            const maxKm = 220;
            const progress = Math.min(100, (totalKm / maxKm) * 100);
            const barLength = 10;
            const filledBars = Math.round((progress / 100) * barLength);
            const progressBar = '‚ñì'.repeat(filledBars) + '‚ñë'.repeat(barLength - filledBars);
            
            // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É —Å—Ç–∞—Ä—Ç–∞ –∑–∞–±–µ–≥–∞
            const raceStartDate = new Date(raceTime.race_start);
            const raceStartStr = raceStartDate.toLocaleDateString('ru-RU', {
              timeZone: 'Europe/Volgograd',
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
            
            // –ö—Ä–∞—Å–∏–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            let message = `üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê –ó–ê–ë–ï–ì–ê</b>\n`;
            message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
            
            message += `üèÅ <b>–î–∞—Ç–∞ —Å—Ç–∞—Ä—Ç–∞ –∑–∞–±–µ–≥–∞:</b>\n`;
            message += `   ${raceStartStr}\n\n`;
            
            message += `üèÉ‚Äç‚ôÇÔ∏è <b>–ö–∏–ª–æ–º–µ—Ç—Ä—ã:</b>\n`;
            message += `   ${totalKm.toFixed(2)} –∫–º\n\n`;
            
            message += `üîÑ <b>–ö—Ä—É–≥–∏:</b>\n`;
            message += `   ${totalLaps} –∫—Ä—É–≥–æ–≤\n\n`;
            
            message += `${rankEmoji} <b>–†–∞–∑—Ä—è–¥:</b>\n`;
            message += `   ${rank}\n\n`;
            
            if (nextRank) {
              message += `üéØ <b>–î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–∞–∑—Ä—è–¥–∞:</b>\n`;
              message += `   ${kmToNext.toFixed(1)} –∫–º (–¥–æ ${nextRank} –∫–º)\n\n`;
            } else {
              message += `üèÜ <b>–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑—Ä—è–¥!</b>\n\n`;
            }
            
            message += `‚è± <b>–ü—Ä–æ—à–ª–æ –≤—Ä–µ–º–µ–Ω–∏:</b>\n`;
            message += `   ${elapsedTime}\n\n`;

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º "–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏" —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∑–∞–±–µ–≥–∞
            if (now >= raceStart && now < raceEnd) {
              message += `‚è≥ <b>–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏:</b>\n`;
              message += `   ${remainingTime}\n\n`;
            }
            
            message += `üìà <b>–ü—Ä–æ–≥—Ä–µ—Å—Å –¥–æ –ö–ú–°:</b>\n`;
            message += `   ${progressBar} ${progress.toFixed(0)}%\n\n`;
            
            message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
            message += `üïê –û–±–Ω–æ–≤–ª–µ–Ω–æ: ${dateStr}`;
            
            const keyboard = isAdmin(userId) ? adminKeyboard : userKeyboard;
            await sendMessage(chatId, message, keyboard);
          } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
            await sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
          }
          await answerCallbackQuery(update.callback_query.id);
          break;

        default:
          await answerCallbackQuery(update.callback_query.id);
      }
    }

    return {
      statusCode: 200,
      headers,
      body: 'OK',
    };

  } catch (error) {
    console.error('Webhook error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ error: error.message }),
    };
  }
};